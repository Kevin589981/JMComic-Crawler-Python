name: 下载JM本子并发送邮件 (dispatch)

on:
  workflow_dispatch:
    inputs:
      JM_ALBUM_IDS:
        type: string
        description: 本子id（多个id用-隔开，如 '123-456-789'）
        required: false

      JM_PHOTO_IDS:
        type: string
        description: 章节id（单独下载章节，多个id同上）
        required: false

      CLIENT_IMPL:
        type: string
        description: 客户端类型（client.impl），下载失败时，你可以尝试填入此项重试。'api' 表示移动端，'html' 表示网页端。
        default: ''
        required: false

      IMAGE_SUFFIX:
        type: string
        description: 图片后缀（download.cache.suffix），默认为空，表示不做图片格式转换。可填入例如 'png' 'jpg'
        default: ''
        required: false

      DIR_RULE:
        type: string
        description: 下载文件夹规则（dir_rule.rule）。默认使用配置文件的 'Bd_Aauthor_Atitle_Pindex'。
        default: ''
        required: false

      ZIP_NAME:
        type: string
        default: 本子.tar.gz
        description: 压缩文件名称
        required: false

      UPLOAD_NAME:
        type: string
        default: Click me to download
        description: 上传文件名称
        required: false

      ENABLE_PDF:
        type: boolean
        default: true
        description: 是否生成PDF文件
        required: false

      PDF_ZIP_NAME:
        type: string
        default: 本子PDF.zip
        description: PDF压缩文件名称
        required: false

      PDF_UPLOAD_NAME:
        type: string
        default: Click me to download PDF
        description: PDF上传文件名称
        required: false

      # EMAIL_TITLE:
      #   type: string
      #   default: JM漫画下载完成
      #   description: 邮件标题
      #   required: false

      # EMAIL_CONTENT:
      #   type: string
      #   default: 您请求的JM漫画已下载完成，请查看附件。
      #   description: 邮件内容
      #   required: false

jobs:
  crawler:
    runs-on: ubuntu-latest
    env:
      # 工作流输入
      JM_ALBUM_IDS: ${{ github.event.inputs.JM_ALBUM_IDS }}
      JM_PHOTO_IDS: ${{ github.event.inputs.JM_PHOTO_IDS }}
      DIR_RULE: ${{ github.event.inputs.DIR_RULE }}
      CLIENT_IMPL: ${{ github.event.inputs.CLIENT_IMPL }}
      ZIP_NAME: ${{ github.event.inputs.ZIP_NAME }}
      UPLOAD_NAME: ${{ github.event.inputs.UPLOAD_NAME }}
      IMAGE_SUFFIX: ${{ github.event.inputs.IMAGE_SUFFIX }}
      ENABLE_PDF: ${{ github.event.inputs.ENABLE_PDF }}
      PDF_ZIP_NAME: ${{ github.event.inputs.PDF_ZIP_NAME }}
      PDF_UPLOAD_NAME: ${{ github.event.inputs.PDF_UPLOAD_NAME }}
      EMAIL_TITLE: "JM漫画下载完成"
      EMAIL_CONTENT: "您请求的JM漫画已下载完成，请查看附件。"

      # 登录相关secrets
      JM_USERNAME: ${{ secrets.JM_USERNAME }}
      JM_PASSWORD: ${{ secrets.JM_PASSWORD }}

      # 邮件相关secrets
      SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
      SMTP_SSL: ${{ secrets.SMTP_SSL }}
      SMTP_EMAIL: ${{ secrets.SMTP_EMAIL }}
      SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
      SMTP_NAME: ${{ secrets.SMTP_NAME }}
      


      # 固定值
      JM_DOWNLOAD_DIR: /home/runner/work/jmcomic/download/
      JM_PDF_DIR: /home/runner/work/jmcomic/pdf/

    steps:
      - uses: actions/checkout@v4
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Dependency
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt
          pip install img2pdf requests

      - name: 安装jmcomic（pip）
        if: ${{ github.ref != 'refs/heads/dev' }}
        run: |
          pip install jmcomic -i https://pypi.org/project --upgrade

      - name: 安装jmcomic（local）
        if: ${{ github.ref == 'refs/heads/dev' }}
        run: |
          pip install -e ./

      - name: 运行下载脚本
        run: |
          cd ./usage/
          python workflow_download.py

      - name: 压缩图片文件
        run: |
          cd $JM_DOWNLOAD_DIR
          tar -zcvf "../$ZIP_NAME" ./
          mv "../$ZIP_NAME" .

      - name: 压缩PDF文件
        if: ${{ github.event.inputs.ENABLE_PDF == 'true' }}
        run: |
          if [ -d "$JM_PDF_DIR" ] && [ "$(ls -A $JM_PDF_DIR)" ]; then
            cd $JM_PDF_DIR
            zip -r "../$PDF_ZIP_NAME" ./
            mv "../$PDF_ZIP_NAME" .
          else
            echo "PDF目录不存在或为空，跳过PDF压缩"
          fi

      - name: 上传图片结果
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.UPLOAD_NAME }}
          path: ${{ env.JM_DOWNLOAD_DIR }}/${{ env.ZIP_NAME }}
          if-no-files-found: error
          retention-days: 90

      - name: 上传PDF结果
        if: ${{ github.event.inputs.ENABLE_PDF == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PDF_UPLOAD_NAME }}
          path: ${{ env.JM_PDF_DIR }}/${{ env.PDF_ZIP_NAME }}
          if-no-files-found: ignore
          retention-days: 90

      # 新增：发送邮件附件功能
      - name: 准备邮件附件
        run: |
          echo "准备邮件附件..."
          mkdir -p ./email_attachments
          
          # 复制图片压缩文件
          if [ -f "$JM_DOWNLOAD_DIR/$ZIP_NAME" ]; then
            cp "$JM_DOWNLOAD_DIR/$ZIP_NAME" ./email_attachments/
            echo "图片压缩文件已准备: $ZIP_NAME"
          fi
          
          # 复制PDF压缩文件（如果存在）
          if [ "$ENABLE_PDF" == "true" ] && [ -f "$JM_PDF_DIR/$PDF_ZIP_NAME" ]; then
            cp "$JM_PDF_DIR/$PDF_ZIP_NAME" ./email_attachments/
            echo "PDF压缩文件已准备: $PDF_ZIP_NAME"
          fi
          
          # 列出所有附件文件
          echo "附件列表:"
          ls -la ./email_attachments/

      - name: 发送邮件通知
        if: env.SMTP_SERVER != ''
        run: |
          python3 << 'EOF'
          import os
          import smtplib
          import mimetypes
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart
          from email.mime.base import MIMEBase
          from email.header import Header
          from email.utils import formataddr
          from email import encoders
          
          def split_and_send_email(smtp_server, smtp_ssl, smtp_email, smtp_password, smtp_name, 
                                 email_title, email_content, attachments_dir):
              """分批发送邮件以处理大附件"""
              
              if not os.path.exists(attachments_dir):
                  print("附件目录不存在")
                  return
              
              # 获取所有附件文件
              attachment_files = []
              for filename in os.listdir(attachments_dir):
                  file_path = os.path.join(attachments_dir, filename)
                  if os.path.isfile(file_path):
                      attachment_files.append((filename, file_path))
              
              if not attachment_files:
                  print("没有找到附件文件")
                  return
              
              # 按文件大小分组，每组不超过25MB
              max_batch_size = 25 * 1024 * 1024  # 25MB
              batches = []
              current_batch = []
              current_size = 0
              
              for filename, file_path in attachment_files:
                  file_size = os.path.getsize(file_path)
                  
                  # 如果单个文件就超过25MB，跳过
                  if file_size > max_batch_size:
                      print(f"警告: 文件 {filename} 过大 ({file_size} bytes)，跳过")
                      continue
                  
                  # 如果加入当前文件会超过限制，开始新批次
                  if current_size + file_size > max_batch_size and current_batch:
                      batches.append(current_batch)
                      current_batch = []
                      current_size = 0
                  
                  current_batch.append((filename, file_path, file_size))
                  current_size += file_size
              
              # 添加最后一个批次
              if current_batch:
                  batches.append(current_batch)
              
              print(f"将分 {len(batches)} 批次发送邮件")
              
              # 发送每个批次
              for i, batch in enumerate(batches, 1):
                  batch_title = f"{email_title} (第{i}批，共{len(batches)}批)" if len(batches) > 1 else email_title
                  batch_content = f"{email_content}\n\n本批次包含 {len(batch)} 个文件。"
                  
                  send_single_email(smtp_server, smtp_ssl, smtp_email, smtp_password, smtp_name,
                                  batch_title, batch_content, batch)
          
          def send_single_email(smtp_server, smtp_ssl, smtp_email, smtp_password, smtp_name,
                               title, content, attachments):
              """发送单个邮件"""
              try:
                  # 构建邮件
                  message = MIMEMultipart()
                  
                  # 添加文本内容
                  text_part = MIMEText(content, 'plain', 'utf-8')
                  message.attach(text_part)
                  
                  # 添加附件
                  total_size = 0
                  for filename, file_path, file_size in attachments:
                      total_size += file_size
                      
                      with open(file_path, 'rb') as f:
                          file_data = f.read()
                      
                      # 猜测MIME类型
                      content_type, _ = mimetypes.guess_type(file_path)
                      if content_type is None:
                          content_type = 'application/octet-stream'
                      
                      # 创建附件对象
                      main_type, sub_type = content_type.split('/', 1)
                      attachment_part = MIMEBase(main_type, sub_type)
                      attachment_part.set_payload(file_data)
                      encoders.encode_base64(attachment_part)
                      
                      # 设置附件头
                      attachment_part.add_header(
                          'Content-Disposition',
                          f'attachment; filename="{filename}"'
                      )
                      
                      message.attach(attachment_part)
                      print(f"添加附件: {filename} ({file_size} bytes)")
                  
                  # 设置邮件头
                  message['From'] = formataddr((Header(smtp_name, 'utf-8').encode(), smtp_email))
                  message['To'] = formataddr((Header(smtp_name, 'utf-8').encode(), smtp_email))
                  message['Subject'] = Header(title, 'utf-8')
                  
                  # 发送邮件
                  if smtp_ssl.lower() == 'true':
                      smtp_client = smtplib.SMTP_SSL(smtp_server)
                  else:
                      smtp_client = smtplib.SMTP(smtp_server)
                  
                  smtp_client.login(smtp_email, smtp_password)
                  smtp_client.sendmail(smtp_email, smtp_email, message.as_string())
                  smtp_client.close()
                  
                  print(f"✓ 邮件发送成功: {title} (总大小: {total_size} bytes)")
                  
              except Exception as e:
                  print(f"✗ 邮件发送失败: {str(e)}")
                  raise e
          
          # 获取环境变量
          smtp_server = os.environ.get('SMTP_SERVER')
          smtp_ssl = os.environ.get('SMTP_SSL', 'true')
          smtp_email = os.environ.get('SMTP_EMAIL')
          smtp_password = os.environ.get('SMTP_PASSWORD')
          smtp_name = os.environ.get('SMTP_NAME', 'JM漫画下载服务')
          email_title = os.environ.get('EMAIL_TITLE', 'JM漫画下载完成')
          email_content = os.environ.get('EMAIL_CONTENT', '您请求的JM漫画已下载完成，请查看附件。')
          
          # 检查必要的配置
          if not all([smtp_server, smtp_email, smtp_password]):
              print("错误: SMTP配置不完整")
              exit(1)
          
          # 发送邮件
          split_and_send_email(smtp_server, smtp_ssl, smtp_email, smtp_password, smtp_name,
                              email_title, email_content, './email_attachments')
          EOF

      - name: 清理临时文件
        if: always()
        run: |
          echo "清理临时文件..."
          rm -rf ./email_attachments
          echo "清理完成"